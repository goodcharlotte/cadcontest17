!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
AND	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
BUF	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
Circuit_t	circuit.cpp	/^Circuit_t::Circuit_t()$/;"	f	class:Circuit_t
Circuit_t	datatype.h	/^class Circuit_t$/;"	c
EN_DEBUG_SIM	datatype.h	11;"	d
GRAY_ERROR	datatype.h	19;"	d
GRAY_INIT	datatype.h	18;"	d
GRAY_NO_CHAGNE	datatype.h	20;"	d
GateType	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	g
NAND	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
NOR	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
NOT	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
NXOR	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
Node_t	datatype.h	/^class Node_t$/;"	c
Node_t	node.cpp	/^Node_t::Node_t(string n, GateType t) : name(n), type(t) $/;"	f	class:Node_t
OFFSET_BIT	datatype.h	17;"	d
OR	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
PORT	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
XOR	datatype.h	/^enum GateType {BUF, NOT, AND, NAND, OR, NOR, XOR, NXOR, PORT};$/;"	e	enum:GateType
_DATATYPE_	datatype.h	2;"	d
addinput	datatype.h	/^    inline void addinput(int i) { in.push_back(i); }$/;"	f	class:Node_t
addoutput	datatype.h	/^    inline void addoutput(int i) { out.push_back(i); }$/;"	f	class:Node_t
allnodemap	datatype.h	/^    map<string, int> allnodemap;$/;"	m	class:Circuit_t
allnodevalue	datatype.h	/^	vector<int> allnodevalue;$/;"	m	class:Circuit_t
allnodevec	datatype.h	/^    vector<Node_t> allnodevec;$/;"	m	class:Circuit_t
calculate_gate_out	simulation.cpp	/^int Circuit_t::calculate_gate_out(GateType gate_type, vector<int> in)$/;"	f	class:Circuit_t
debug_print	datatype.h	12;"	d
generate_graycode	simulation.cpp	/^vector<int> generate_graycode(int n)$/;"	f
getName	datatype.h	/^    inline string getName() { return name; }$/;"	f	class:Node_t
getType	datatype.h	/^    inline GateType getType() { return type; }$/;"	f	class:Node_t
get_pi_size	datatype.h	/^	int get_pi_size() { return pi.size(); }$/;"	f	class:Circuit_t
greycode_diff	datatype.h	/^	vector<int> greycode_diff;$/;"	m	class:Circuit_t
in	datatype.h	/^    vector<int> in;$/;"	m	class:Node_t
init_simulation	simulation.cpp	/^void Circuit_t::init_simulation() $/;"	f	class:Circuit_t
input_target_pattern	simulation.cpp	/^void Circuit_t::input_target_pattern(int target_value)$/;"	f	class:Circuit_t
iter	datatype.h	/^    map<string, int>::iterator iter;$/;"	m	class:Circuit_t
main	main.cpp	/^int main(int argc, char * argv[])$/;"	f
name	datatype.h	/^    string name;$/;"	m	class:Node_t
out	datatype.h	/^    vector<int> out;$/;"	m	class:Node_t
pi	datatype.h	/^    vector<int> pi;$/;"	m	class:Circuit_t
po	datatype.h	/^    vector<int> po;$/;"	m	class:Circuit_t
po_value	datatype.h	/^	vector<int> po_value;$/;"	m	class:Circuit_t
print	circuit.cpp	/^void Circuit_t::print()$/;"	f	class:Circuit_t
print	node.cpp	/^void Node_t::print(vector<Node_t> allnode)$/;"	f	class:Node_t
print_pi	simulation.cpp	/^void Circuit_t::print_pi()$/;"	f	class:Circuit_t
print_po	simulation.cpp	/^void Circuit_t::print_po()$/;"	f	class:Circuit_t
readfile	circuit.cpp	/^bool Circuit_t::readfile(char* fname)$/;"	f	class:Circuit_t
setType	datatype.h	/^    inline void setType(GateType t) { type = t; }$/;"	f	class:Node_t
simulation	simulation.cpp	/^void Circuit_t::simulation(int gray_diff)$/;"	f	class:Circuit_t
target	datatype.h	/^	vector<int> target;$/;"	m	class:Circuit_t
topology	simulation.cpp	/^void Circuit_t::topology(int graycode_diff)$/;"	f	class:Circuit_t
topology_order	datatype.h	/^    vector<int> topology_order;$/;"	m	class:Circuit_t
type	datatype.h	/^    GateType type;$/;"	m	class:Node_t
writefile	circuit.cpp	/^bool Circuit_t::writefile(char* fname)$/;"	f	class:Circuit_t
